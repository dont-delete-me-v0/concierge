import { Ctx, Hears, InjectBot, On, Start, Update } from 'nestjs-telegraf';
import type { Context, Scenes } from 'telegraf';
import { Markup } from 'telegraf';
import { EventsApiService } from './events-api.service.js';
import { formatEventCard, mainKeyboard, resolveEventUrl } from './keyboards.js';

export interface SessionData {
  selectedCategories?: string[];
  events?: import('./events-api.service.js').EventItem[];
  currentIndex?: number;
  view?: 'card' | 'list';
  searchMode?: 'name' | 'price' | 'venue' | null;
  searchParams?: any; // Last search params for lazy loading
  totalEvents?: number; // Total count from server
}

export type BotContext = Context &
  Scenes.WizardContext & { session: SessionData };

@Update()
export class BotUpdate {
  constructor(
    private readonly eventsApi: EventsApiService,
    @InjectBot() private readonly bot: any
  ) {}

  @Start()
  async onStart(@Ctx() ctx: BotContext) {
    await ctx.reply(
      '–ü—Ä–∏–≤–µ—Ç! –Ø –ø–æ–º–æ–≥—É –Ω–∞–π—Ç–∏ –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏—è. –í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ –Ω–∏–∂–µ.',
      mainKeyboard()
    );
  }

  @Hears('üîç –ü–æ–∏—Å–∫')
  async onSearchMenu(@Ctx() ctx: BotContext) {
    await ctx.reply(
      '–í—ã–±–µ—Ä–∏—Ç–µ —Ç–∏–ø –ø–æ–∏—Å–∫–∞:',
      Markup.keyboard([
        ['–ü–æ –Ω–∞–∑–≤–∞–Ω–∏—é', '–ü–æ –∞–¥—Ä–µ—Å—É'],
        ['–ü–æ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏', '–ü–æ –¥–∞—Ç–µ'],
        ['–ü–æ —Ü–µ–Ω–µ'],
        ['‚¨ÖÔ∏è –ù–∞–∑–∞–¥'],
      ]).resize()
    );
  }

  @Hears('‚¨ÖÔ∏è –ù–∞–∑–∞–¥')
  async onBack(@Ctx() ctx: BotContext) {
    ctx.session.searchMode = null;
    await ctx.reply('–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é:', mainKeyboard());
  }

  @Hears('–ü–æ –Ω–∞–∑–≤–∞–Ω–∏—é')
  async onSearchByName(@Ctx() ctx: BotContext) {
    ctx.session.searchMode = 'name';
    await ctx.reply('–í–≤–µ–¥–∏—Ç–µ —á–∞—Å—Ç—å –Ω–∞–∑–≤–∞–Ω–∏—è –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏—è:');
  }

  @Hears('–ü–æ –∞–¥—Ä–µ—Å—É')
  async onSearchByVenue(@Ctx() ctx: BotContext) {
    ctx.session.searchMode = 'venue';
    await ctx.reply('–í–≤–µ–¥–∏—Ç–µ —á–∞—Å—Ç—å –Ω–∞–∑–≤–∞–Ω–∏—è –ø–ª–æ—â–∞–¥–∫–∏ (–∞–¥—Ä–µ—Å/venue name):');
  }

  @Hears('–ü–æ –¥–∞—Ç–µ')
  async onSearchByDate(@Ctx() ctx: BotContext) {
    await ctx.reply(
      '–í—ã–±–µ—Ä–∏—Ç–µ –ø–µ—Ä–∏–æ–¥:',
      Markup.inlineKeyboard([
        [Markup.button.callback('–°–µ–≥–æ–¥–Ω—è', 's:d:today')],
        [Markup.button.callback('–ó–∞–≤—Ç—Ä–∞', 's:d:tomorrow')],
        [Markup.button.callback('7 –¥–Ω–µ–π', 's:d:week')],
        [Markup.button.callback('–í–≤–µ—Å—Ç–∏ –≤—Ä—É—á–Ω—É—é', 's:d:manual')],
      ])
    );
  }

  @Hears('–ü–æ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏')
  async onSearchByCategory(@Ctx() ctx: BotContext) {
    const cats = await this.eventsApi.categories();
    if (!cats.length) {
      await ctx.reply('–ö–∞—Ç–µ–≥–æ—Ä–∏–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã');
      return;
    }
    // Chunk categories into rows of 2-3 buttons
    const rows: any[] = [];
    const tokens: string[] = [];
    for (const c of cats) {
      const token = this.eventsApi.tokenForEventId(c.id);
      tokens.push(token);
    }
    for (let i = 0; i < cats.length; i += 3) {
      rows.push(
        cats
          .slice(i, i + 3)
          .map((c, j) => Markup.button.callback(c.name, `s:c:${tokens[i + j]}`))
      );
    }
    await ctx.reply('–í—ã–±–µ—Ä–∏—Ç–µ –∫–∞—Ç–µ–≥–æ—Ä–∏—é:', Markup.inlineKeyboard(rows));
  }

  @Hears('–ü–æ —Ü–µ–Ω–µ')
  async onSearchByPrice(@Ctx() ctx: BotContext) {
    ctx.session.searchMode = 'price';
    await ctx.reply(
      '–í–≤–µ–¥–∏—Ç–µ –¥–∏–∞–ø–∞–∑–æ–Ω —Ü–µ–Ω –≤ —Ñ–æ—Ä–º–∞—Ç–µ:\n- 100-500 (–æ—Ç 100 –¥–æ 500 –≥—Ä–Ω)\n- 200 (–æ—Ç 200 –≥—Ä–Ω)\n- -300 (–¥–æ 300 –≥—Ä–Ω)'
    );
  }

  @Hears('‚ö°Ô∏è –ß—Ç–æ —Å–µ–≥–æ–¥–Ω—è?')
  async onToday(@Ctx() ctx: BotContext) {
    const now = new Date();
    const today = now.toISOString().split('T')[0];
    const searchParams = {
      dateFrom: today,
      dateTo: today,
      limit: 10,
      offset: 0,
    };
    const { items: events, total } = await this.eventsApi.search(searchParams);
    if (!events.length) {
      await ctx.reply('–ù–∞ —Å–µ–≥–æ–¥–Ω—è –Ω–∏—á–µ–≥–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.');
      return;
    }
    ctx.session.events = events;
    ctx.session.totalEvents = total;
    ctx.session.searchParams = searchParams;
    ctx.session.currentIndex = 0;
    ctx.session.view = 'card';
    const first = events[0];
    await ctx.replyWithHTML(
      formatEventCard(first),
      this.buildCardKeyboard(first, 0, total)
    );
  }

  @On('callback_query')
  async onCallback(@Ctx() ctx: BotContext) {
    const data = String((ctx.callbackQuery as any)?.data ?? '');
    // Legacy details token
    if (data.startsWith('d:')) {
      const token = data.slice(2);
      const id = this.eventsApi.resolveEventId(token);
      if (!id) {
        await ctx.answerCbQuery('–°—Å—ã–ª–∫–∞ —É—Å—Ç–∞—Ä–µ–ª–∞');
        return;
      }
      const event = await this.eventsApi.getById(id);
      if (!event) {
        await ctx.answerCbQuery('–ú–µ—Ä–æ–ø—Ä–∏—è—Ç–∏–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ');
      } else {
        await ctx.replyWithHTML(formatEventCard(event));
        await ctx.answerCbQuery();
      }
      return;
    }

    if (data === 'noop') {
      await ctx.answerCbQuery();
      return;
    }

    // Navigation: prev/next with lazy loading
    if (data === 'nav:p' || data === 'nav:n') {
      const events = ctx.session.events ?? [];
      const total = ctx.session.totalEvents ?? events.length;
      const current = ctx.session.currentIndex ?? 0;
      const nextIndex = data === 'nav:p' ? current - 1 : current + 1;

      if (nextIndex < 0 || nextIndex >= total) {
        await ctx.answerCbQuery('–≠—Ç–æ –ø–µ—Ä–≤–∞—è/–ø–æ—Å–ª–µ–¥–Ω—è—è –∫–∞—Ä—Ç–æ—á–∫–∞');
        return;
      }

      // Check if we need to load more events
      if (nextIndex >= events.length || !events[nextIndex]) {
        const searchParams = ctx.session.searchParams ?? {};
        const offset = Math.floor(nextIndex / 10) * 10;
        const { items: newEvents } = await this.eventsApi.search({
          ...searchParams,
          limit: 10,
          offset,
        });
        // Merge new events into the existing array
        if (!ctx.session.events) ctx.session.events = [];
        for (let i = 0; i < newEvents.length; i++) {
          ctx.session.events[offset + i] = newEvents[i];
        }
      }

      ctx.session.currentIndex = nextIndex;
      ctx.session.view = 'card';
      const e = (ctx.session.events ?? [])[nextIndex];
      if (!e) {
        await ctx.answerCbQuery('–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å —Å–æ–±—ã—Ç–∏–µ');
        return;
      }
      await ctx.editMessageText(formatEventCard(e), {
        parse_mode: 'HTML',
        ...this.buildCardKeyboard(e, nextIndex, total),
      });
      await ctx.answerCbQuery();
      return;
    }

    // Switch view: list or card
    if (data === 'view:list') {
      ctx.session.view = 'list';
      await this.renderList(ctx, 0);
      await ctx.answerCbQuery();
      return;
    }
    if (data === 'view:card') {
      const events = ctx.session.events ?? [];
      const total = ctx.session.totalEvents ?? events.length;
      const idx = ctx.session.currentIndex ?? 0;
      const e = events[idx];
      if (e) {
        ctx.session.view = 'card';
        await ctx.editMessageText(formatEventCard(e), {
          parse_mode: 'HTML',
          ...this.buildCardKeyboard(e, idx, total),
        });
      }
      await ctx.answerCbQuery();
      return;
    }

    // List navigation go to item index
    if (data.startsWith('go:')) {
      const idx = Number(data.slice(3));
      const events = ctx.session.events ?? [];
      const total = ctx.session.totalEvents ?? events.length;
      if (Number.isNaN(idx) || idx < 0 || idx >= total) {
        await ctx.answerCbQuery('–≠–ª–µ–º–µ–Ω—Ç –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω');
        return;
      }

      // Load event if not yet loaded
      if (!events[idx]) {
        const offset = Math.floor(idx / 10) * 10;
        const searchParams = ctx.session.searchParams ?? {};
        const { items: newEvents } = await this.eventsApi.search({
          ...searchParams,
          limit: 10,
          offset,
        });
        // Merge loaded events
        if (!ctx.session.events) ctx.session.events = [];
        for (let i = 0; i < newEvents.length; i++) {
          ctx.session.events[offset + i] = newEvents[i];
        }
      }

      ctx.session.currentIndex = idx;
      ctx.session.view = 'card';
      const e = (ctx.session.events ?? [])[idx];
      if (!e) {
        await ctx.answerCbQuery('–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å —Å–æ–±—ã—Ç–∏–µ');
        return;
      }
      await ctx.editMessageText(formatEventCard(e), {
        parse_mode: 'HTML',
        ...this.buildCardKeyboard(e, idx, total),
      });
      await ctx.answerCbQuery();
      return;
    }

    // List page navigation
    if (data.startsWith('list:')) {
      const parts = data.split(':');
      const next = Number(parts[2]);
      if (!Number.isFinite(next)) {
        await ctx.answerCbQuery('–°—Ç—Ä–∞–Ω–∏—Ü–∞ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞');
        return;
      }
      await this.renderList(ctx, next);
      await ctx.answerCbQuery();
      return;
    }

    // Search by date actions
    if (data.startsWith('s:d:')) {
      const dateKey = data.slice(4) as 'today' | 'tomorrow' | 'week' | 'manual';
      if (dateKey === 'manual') {
        await ctx.editMessageText(
          '–í–≤–µ–¥–∏—Ç–µ –¥–∞—Ç—É –∏–ª–∏ –¥–∏–∞–ø–∞–∑–æ–Ω –≤ —Ñ–æ—Ä–º–∞—Ç–µ:\n- 2025-10-15 (–¥–∞—Ç–∞)\n- 2025-10-15T14:30 (–¥–∞—Ç–∞ –∏ –≤—Ä–µ–º—è)\n- 2025-10-15 ‚Äî 2025-10-20 (–¥–∏–∞–ø–∞–∑–æ–Ω –¥–∞—Ç)\n- 2025-10-15T10:00 ‚Äî 2025-10-15T18:00 (–¥–∏–∞–ø–∞–∑–æ–Ω –≤—Ä–µ–º–µ–Ω–∏)',
          { parse_mode: undefined }
        );
        // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ç–µ–∫—Å—Ç–æ–≤—ã–π —Ö—ç–Ω–¥–ª–µ—Ä –Ω–∏–∂–µ –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –≤–≤–æ–¥–∞
        await ctx.answerCbQuery();
        return;
      }
      const now = new Date();
      let dateFrom: string;
      let dateTo: string;
      if (dateKey === 'today') {
        dateFrom = now.toISOString().split('T')[0];
        dateTo = dateFrom;
      } else if (dateKey === 'tomorrow') {
        const t = new Date(now);
        t.setDate(now.getDate() + 1);
        dateFrom = t.toISOString().split('T')[0];
        dateTo = dateFrom;
      } else if (dateKey === 'week') {
        dateFrom = now.toISOString().split('T')[0];
        const week = new Date(now);
        week.setDate(now.getDate() + 7);
        dateTo = week.toISOString().split('T')[0];
      } else {
        await ctx.answerCbQuery('–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ñ–∏–ª—å—Ç—Ä');
        return;
      }
      const searchParams = { dateFrom, dateTo, limit: 10, offset: 0 };
      const { items: events, total } =
        await this.eventsApi.search(searchParams);
      if (!events.length) {
        await ctx.editMessageText('–ù–∏—á–µ–≥–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ –∑–∞ –≤—ã–±—Ä–∞–Ω–Ω—ã–π –ø–µ—Ä–∏–æ–¥');
        await ctx.answerCbQuery();
        return;
      }
      ctx.session.events = events;
      ctx.session.totalEvents = total;
      ctx.session.searchParams = searchParams;
      ctx.session.currentIndex = 0;
      ctx.session.view = 'card';
      const first = events[0];
      await ctx.editMessageText(formatEventCard(first), {
        parse_mode: 'HTML',
        ...this.buildCardKeyboard(first, 0, total),
      });
      await ctx.answerCbQuery();
      return;
    }

    if (data.startsWith('s:c:')) {
      const token = data.slice(4);
      const id = this.eventsApi.resolveEventId(token);
      if (!id) {
        await ctx.answerCbQuery('–ö–∞—Ç–µ–≥–æ—Ä–∏—è –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞');
        return;
      }
      const searchParams = { categoryId: id, limit: 10, offset: 0 };
      const { items: events, total } =
        await this.eventsApi.search(searchParams);
      if (!events.length) {
        await ctx.editMessageText('–í —ç—Ç–æ–π –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –Ω–∏—á–µ–≥–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ');
        await ctx.answerCbQuery();
        return;
      }
      ctx.session.events = events;
      ctx.session.totalEvents = total;
      ctx.session.searchParams = searchParams;
      ctx.session.currentIndex = 0;
      ctx.session.view = 'card';
      const first = events[0];
      await ctx.editMessageText(formatEventCard(first), {
        parse_mode: 'HTML',
        ...this.buildCardKeyboard(first, 0, total),
      });
      await ctx.answerCbQuery();
      return;
    }
  }

  @On('text')
  async onText(@Ctx() ctx: BotContext) {
    const mode = ctx.session.searchMode ?? null;
    const text = String((ctx.message as any)?.text ?? '').trim();
    if (!text || text.startsWith('/')) return;
    // Manual date input (supports both date and datetime)
    const manualDateMatch = text.match(
      /^(\d{4}-\d{2}-\d{2}(?:T\d{2}:\d{2}(?::\d{2})?)?)(?:\s*[‚Äì‚Äî-]\s*(\d{4}-\d{2}-\d{2}(?:T\d{2}:\d{2}(?::\d{2})?)?))?$/
    );
    if (manualDateMatch) {
      const [, from, to] = manualDateMatch;
      console.log('[BotUpdate] Manual date input - from:', from, 'to:', to);

      // Convert local time to UTC for API
      const convertToUTC = (localTime: string) => {
        const date = new Date(localTime);
        return date.toISOString();
      };

      const searchParams: any = {
        dateFrom: convertToUTC(from),
        limit: 10,
        offset: 0,
      };
      if (to) searchParams.dateTo = convertToUTC(to);
      else searchParams.dateTo = convertToUTC(from);

      console.log('[BotUpdate] Search params (UTC):', searchParams);
      const { items: events, total } =
        await this.eventsApi.search(searchParams);
      if (!events.length) {
        await ctx.reply('–ù–∏—á–µ–≥–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ –¥–ª—è —É–∫–∞–∑–∞–Ω–Ω–æ–π –¥–∞—Ç—ã/–¥–∏–∞–ø–∞–∑–æ–Ω–∞.');
        return;
      }
      ctx.session.events = events;
      ctx.session.totalEvents = total;
      ctx.session.searchParams = searchParams;
      ctx.session.currentIndex = 0;
      ctx.session.view = 'card';
      const first = events[0];
      await ctx.replyWithHTML(
        formatEventCard(first),
        this.buildCardKeyboard(first, 0, total)
      );
      return;
    }

    // Price range input
    if (mode === 'price') {
      const priceMatch = text.match(/^(-?\d+)(?:-(-?\d+))?$/);
      if (!priceMatch) {
        await ctx.reply(
          '–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç —Ü–µ–Ω—ã. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ: 100-500, 200, –∏–ª–∏ -300'
        );
        return;
      }
      const [, fromStr, toStr] = priceMatch;
      const searchParams: any = { limit: 10, offset: 0 };
      if (fromStr.startsWith('-')) {
        // Only upper bound: -300 means up to 300
        searchParams.priceTo = Math.abs(Number(fromStr));
      } else if (toStr) {
        // Range: 100-500
        searchParams.priceFrom = Number(fromStr);
        searchParams.priceTo = Number(toStr);
      } else {
        // Only lower bound: 200 means from 200
        searchParams.priceFrom = Number(fromStr);
      }
      const { items: events, total } =
        await this.eventsApi.search(searchParams);
      if (!events.length) {
        await ctx.reply('–ù–∏—á–µ–≥–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ –≤ —É–∫–∞–∑–∞–Ω–Ω–æ–º —Ü–µ–Ω–æ–≤–æ–º –¥–∏–∞–ø–∞–∑–æ–Ω–µ.');
        return;
      }
      ctx.session.events = events;
      ctx.session.totalEvents = total;
      ctx.session.searchParams = searchParams;
      ctx.session.currentIndex = 0;
      ctx.session.view = 'card';
      const first = events[0];
      await ctx.replyWithHTML(
        formatEventCard(first),
        this.buildCardKeyboard(first, 0, total)
      );
      return;
    }

    if (mode !== 'name' && mode !== 'venue') return;
    const searchParams =
      mode === 'name'
        ? { q: text, limit: 10, offset: 0 }
        : { venueName: text, limit: 10, offset: 0 };
    const { items: events, total } = await this.eventsApi.search(searchParams);
    if (!events.length) {
      await ctx.reply('–ù–∏—á–µ–≥–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —É—Ç–æ—á–Ω–∏—Ç—å –∑–∞–ø—Ä–æ—Å.');
      return;
    }

    ctx.session.events = events;
    ctx.session.totalEvents = total;
    ctx.session.searchParams = searchParams;
    ctx.session.currentIndex = 0;
    ctx.session.view = 'card';
    const first = events[0];
    await ctx.replyWithHTML(
      formatEventCard(first),
      this.buildCardKeyboard(first, 0, total)
    );
  }

  private buildCardKeyboard(
    e: import('./events-api.service.js').EventItem,
    index: number,
    total: number
  ) {
    const navRow = [
      Markup.button.callback('‚óÄÔ∏è', 'nav:p'),
      Markup.button.callback(`${index + 1}/${total}`, 'noop'),
      Markup.button.callback('‚ñ∂Ô∏è', 'nav:n'),
    ];
    const listRow = [Markup.button.callback('üìã –°–ø–∏—Å–æ–∫', 'view:list')];
    const abs = resolveEventUrl(e.source_url);
    const openRow = abs ? [Markup.button.url('üîó –û—Ç–∫—Ä—ã—Ç—å', abs)] : [];
    return Markup.inlineKeyboard([
      navRow,
      listRow,
      ...(openRow.length ? [openRow] : []),
    ]);
  }

  private async renderList(ctx: BotContext, page: number) {
    const total = ctx.session.totalEvents ?? ctx.session.events?.length ?? 0;
    const pageSize = 5;
    const totalPages = Math.max(1, Math.ceil(total / pageSize));
    const bounded = Math.max(0, Math.min(totalPages - 1, page));
    const start = bounded * pageSize;
    const end = Math.min(start + pageSize, total);

    // Load events for this page if not yet loaded
    if (!ctx.session.events) ctx.session.events = [];
    for (let i = start; i < end; i++) {
      if (!ctx.session.events[i]) {
        // Need to load this event
        const offset = Math.floor(i / 10) * 10;
        const searchParams = ctx.session.searchParams ?? {};
        const { items: newEvents } = await this.eventsApi.search({
          ...searchParams,
          limit: 10,
          offset,
        });
        // Merge loaded events
        for (let j = 0; j < newEvents.length; j++) {
          ctx.session.events[offset + j] = newEvents[j];
        }
      }
    }

    // Get events for current page
    const slice: any[] = [];
    for (let i = start; i < end; i++) {
      const e = ctx.session.events[i];
      if (e) slice.push(e);
    }

    const lines = slice.map((e, i) => {
      const num = start + i + 1;
      const date = e.date_time_from ?? e.date_time ?? e.date_time_to;
      const dateStr = date
        ? new Date(date).toLocaleString('ru-RU', {
            dateStyle: 'short',
            timeStyle: 'short',
          })
        : '';
      return `${num}. ${e.title ?? '–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è'}${dateStr ? ` ‚Äî ${dateStr}` : ''}`;
    });
    const header = `–ù–∞–π–¥–µ–Ω–æ: ${total}\n–°—Ç—Ä–∞–Ω–∏—Ü–∞ ${bounded + 1}/${totalPages}`;
    const text = [header, '', ...lines].join('\n');

    // Build number buttons for this page
    const numberButtons = slice.map((_, i) =>
      Markup.button.callback(String(start + i + 1), `go:${start + i}`)
    );
    const numbersRows: any[] = [];
    // chunk by 5 per row
    for (let i = 0; i < numberButtons.length; i += 5) {
      numbersRows.push(numberButtons.slice(i, i + 5));
    }
    const navRow = [
      Markup.button.callback('‚óÄÔ∏è', `list:p:${bounded - 1}`),
      Markup.button.callback(`${bounded + 1}/${totalPages}`, 'noop'),
      Markup.button.callback('‚ñ∂Ô∏è', `list:n:${bounded + 1}`),
    ];
    const toCardRow = [Markup.button.callback('üîô –ö –∫–∞—Ä—Ç–æ—á–∫–µ', 'view:card')];

    await ctx.editMessageText(text, {
      parse_mode: undefined,
      reply_markup: {
        inline_keyboard: [...numbersRows, navRow, toCardRow],
      },
    });
  }
}
